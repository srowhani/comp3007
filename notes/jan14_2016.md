## 2.6 - Substitution Model for Procedure Application

#### Normal Order Evaluation
  - __arguments are evaluated when need be. Delaying the evaluation of the arguments until they are actually needed.__
  - aka _Lazy Evaluation_
  - Expand and Reduce

#### Applicative Order Evaluation
  - __All arguments are evaluated when the procedure is applied__
  - Evaluate operator and operands
  - Apply the resulting procedure to resulting arguments.

        (f 5)
        (sum-of-squares (+ 5 1) (* 5 2))
        (+ (square 6) (square 10))
        (+ ( * 6 6 ) (* 10 10))
        (+ 36 100)
        136


    ;applicative
    (h 2 3)
    (+ (f 2) (g 3))
    (+ (sum-of-squares) (+ 2 1) (* 2 2) (triple (sum-of-squares (double 3) (- 3))))
    ...

    ;normal
    (h 2 3)
    (+ (f 2) (g 3))
    (+ (s-o-s (+ 2 1) (* 2 2)) (triple (s-o-s (double 3) (- 3))))
    (+ (+ ( * ( + 2 1) (+ 2 1))(* (* 2 2) (* 2 2))) (+ (s-o-s (double 3) (- 3))))
    ...

__Example of Lazy Evaluation not being a problem__

    (define (try a b)
      (if (= a 0) 1 b))

  With arguments (0, 1/0), generates an error because __racket uses applicative order__.

  You can use `#lang lazy` to use lazy eval.

### Which Method of Evaluation is Better

Applicative is more efficient

# 3 - Building Abstractions with Procedures

## 3.1  - Conditional Expressions and Predicates

    |x| =  x if x>0  ? (0 of x = 0) : (-x if x < 0)

`cond` procedure

    (cond ( <p1> <e1>)
          ( <p2> <e2>)
          ...
          ( <pn> <en>))

Expression of the form `( <p> <e>)` is called a __clause__

First expression in clause is called a __predicate__.
Similar to the way a __unary statement__ works.


      (define (abs x)
        (cond (( > x 0) x) ; if x greater than 0, return x
          (( = x 0) 0) ; if x == 0 return 0
          ((< x 0) (- x)); if x < 0 return -x
        )
      )

`cond` is different from regular evaluation
For example if the first condition was false, the other arguments would not be evaluated. For example if you had a procedure that recursed infinitely, if the argument was false, it would never evaluate.

    (define (ex1 x y) (if (> x 5) (+ y 10) (* y 10)))


    (define (ex2 x y z)
      (
        (if (> x 5) + * )
        (if (< y 10) y z)
        (if (and (< x y)(< z y))
          (- y x)
          (+ x z)
        )
      )
    )

### Computing Square Roots using Newton's method of successive approximations.

  - Guess y for value of square root of number x
  - To get a better guess average y with x/y


      (define (good-enough? guess x)
          (< (abs (- (square guess) x)) 0.001))
      (define (average x y)
          (/ (+ x y) 2))

      (define (improve guess x)
          (average guess ( / x guess)))

      (define (sqrt-iteration guess x)
          (if (good-enough? guess x)
                  guess
                  (sqrt-iteration (improve guess x) x)))

      (define (sqrt x)
          (sqrt-iteration 1.0 x))
