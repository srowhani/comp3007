Factorial Function
```rkt
    ;n! = n * (n-1) * (n-2) ... 3 * 2 * 1
    ;n! = n*(n-1)!
```

```rkt
  ;linear recursive process
  ;;expansion followed by contraction
  ;;there is a chain of deferred operations(*)
  ;;The amount of information to keep track grows linearly...
  (define (factorial n)
    (if ( = n 1)
      +1
      (* n (factorial (- n 1)))))

  ; if n = 1, return 1
  ; else you continue recursing
```


```rkt
  ;;linear iterative process of the factorial Function
  ;;can be computed in constant space
  ;;iterative method is called tailed recursive
  ;;does the work then calls itself
  ;;as opposed to recursive which calls itself and evaluates as it processes.

  ;;scheme has an optimization in the back that allows this to do this in constant space.
  ;;in python this could fill up the stack.

  ;;the number of steps will grow linearly.
  (define (factorial-iteration product count max)
    (if (> count max)
      product
      (factorial-iteration (* count product) (+ count 1) max)
    )
  )
  (define (factorial n)
    (factorial-iteration 1 1 n)
  )

```

How can you tell the difference between iterative and recursive process

One of them adds to the stack

If you call the recursion and its the last thing its doing, it's tail recursive. So it's iterative.

Tail recursive in scheme is iterative.


```rkt
(define (add a b)
  (if (= a 0)
    b
    (+ 1 ( - 1 a) b)
  )
)
```


```rkt
(define (subrange start end)
  (define (helper current sum)
    (if (= current end)
      (+ sum current)
      (helper (+ current 1) (+ sum current))
    )
  )
  (helper start 0)
)
```


subrange
Has an inner helper Function

Tail recursion is better in scheme, is there a case where its not better

Linear recursion easier to define, and in most other programming languages, is more beneficial as it's easier to write as the programmer.

...

Fibonacci Sequence

```rkt
  ;recursive fib
  (define (fib n)
    (cond
      ((= n 0) 0) ;cond is cool cause you can have inf args
      ((= n 1) 1)
      (else
        (+ (fib (- n 1)) (fib (- n 2)) )
      )
    )
  )
  ;iterative fib
  (define (fib n)
    (fib-it 1 0 n)
  )
  (define (fib-it a b count)
    (cond
      ((= count 0) b)
      (else
        (fib-it (+ a b) a (- count 1))
      )
    )
  )

```
